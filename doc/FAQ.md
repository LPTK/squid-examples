# Frequently Asked Questions

## General

#### How do I use a value of type `T`, known at compile-time, as a value of type `Rep[T]` part of the generated program?

If this value is of a type that can be lifted as a constant (like `Int`, `String`, etc.),
you can directly splice it in a `dsl` block, as in `val cst = 42; dsl"$cst"`.

For example, if you have a `Schema` object `sch`,
you can write `val s = sch.size; dsl"$s + 1"`, or equivalently `dsl"${sch.size} + 1"`.
However, note that you cannot write `dsl"$sch.size + 1"`,
as that would try to make **`sch`** a constant in the generated program,
instead of its bare size. (See question below.)


#### Why does `$unquoting` not work as expected?

There are three distinct semantics for unquoting something in a dsl block, with syntax `dsl" ... ${x} ..."` or equivalently `dsl" ... $x ..."` if `x` is an identifier:

 - if the type of `x` is `Rep[T]`, it means `x` is a program fragment that should evaluate to something of type `T`. In this case, the program fragment is placed in the generated program as a value of type `T`.

 - if the type of `x` is `Rep[S] => Rep[T]`, x is converted to a `Rep[S => T]` and unquoted (using the case above).

 - if none of the above apply, then `x` is placed in the generated program as a **_constant_** of type T.

With most code generation backends, one can only have constants of values that can be expressed as literals (like `Int` or `String`). Trying to unquote something like a `List[Int]` will result in an error at code-generation time (as opposed to unquoting a `Rep[List[Int]]` for example, which would be fine).

For example, writing `dsl"${List(1,2)}.size"` will result in an error similar to:
```
java.lang.Exception: This code generator does not know how to generate a constant expression for `scala.List(Constant(1), Constant(2))` 
```

#### I get the error `This code generator does not know how to generate a constant expression for ...`

See question above.


#### Why can't I access variables defined inside a `dsl` block?

The following code fails to compile with `Error: not found: value x`:
```
val someList = List(1,2,3)
dsl"""
  for (x <- 0 until ${someList.length} ) {
    y = ${someList(x)}
  }
"""
```

This is because quotation `dsl"..."` introduces code to be generated by the compiler while
inside a quotation, antiquotation `${...}` introduces code to be executed by the compiler (so, at compile-time).
In the program above, you generate a loop over some range, and then try to execute code at compile-time using the variable `x` that is only available in the generated program (*not* in the compiler).

The solution, if the range is known at compile time (which is the case here), is to loop over that range at compile time, instead of generating a loop. Remember that dsl statements are [effectful](https://github.com/epfldata/sc-public/blob/master/doc/MSP-QQ.md#effectful-reification): whatever `dsl"..."` you put in a compile-time loop will appear in the generated program the same number of times the loop iterated at compile-time.



## Project 2â€“Specific


#### Should we implement any error handling mechanism?

No. Your program will not be tested on erroneous programs that, for example, refer to non-existing columns or produce schemas with name clashes.

**_As a rule of thumb_**, if it does not work with the provided `RecordsLowering`, then it does not have to work with your implementation of `ColumnStoreLowering`.


#### The queries output weird and unexpected results

Make sure you have the latest version of this repository and of the dependencies (you can clear the caches in the `target` folders generated by `sbt`), especially if you are [on Windows](https://github.com/epfldata/sc-public/issues/14).


#### Why does the `relationProject` method take two `Schema` parameters?

This is a minor oversight on our side: there should only be one `Schema` parameter to the `relationJoin` function: the **_final_** schema. Currently, we pass the **_final_** schema twice.
The code in `RecordsLowering` that uses the first `Schema` parameter does behave correctly.


#### Why does the `print` function not work?

If you try using `print` in `dsl` quasiquotes, you will end up with
[strange errors ](https://github.com/epfldata/sc-public/issues/13).
This is because we do not provide a deep embedding for `print`.
This is intended, as it forces you to use string operations before printing out with `println`.


#### What do the `sbt relation-deep/run` and `sbt relation-gen/run` commands do exactly?

The first command, `sbt relation-deep/run`, _compiles_ one program specified in the file `relation-deep/compiler/Main.scala` using our relation-DSL compiler. For this reason, you have to run that command every time you change the program _or_ the compiler (for example, if you change `ColumnStoreLowering.scala`).

The resulting code is generated [by default](https://github.com/epfldata/sc-public/blob/master/relation-dsl/relation-deep/src/main/scala/relation/compiler/RelationCompiler.scala#L52) in `generator-out/src/main/scala/GenApp.scala`.
The `relation-gen` project is just another sbt project defined to run this code easily, using the command `sbt relation-gen/run`.
This is the command that will make the query defined in the compiled program actually execute.

To avoid restarting sbt each time, you can also just type `sbt` in a terminal and enter the commands `relation-deep/run` and `relation-gen/run` directly in the promt.


#### `sbt` does not compile the project successfully

Make sure you are calling sbt from the `relation-dsl` directory (and _not_ from `relation-deep`, for example).
In order to run the compiler and the generated code, see the answer above.


#### Should my query compiler work with other schemas than the ones in the examples provided to us?

[Yes](http://moodle.epfl.ch/mod/forum/discuss.php?d=6565).



